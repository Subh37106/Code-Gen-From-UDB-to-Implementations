// This Python script reads a YAML file containing RISC-V instruction definitions and generates a C header file (instructions.h).
import yaml
import sys
import os

def generate_c_header(yaml_data, output_path):
    """
    Generates a C header file from parsed YAML data.
    """
    with open(output_path, 'w') as f):
        f.write("/* Auto-generated by yaml_to_c.py. Do not edit. */\n\n")
        f.write("#ifndef INSTRUCTIONS_H\n")
        f.write("#define INSTRUCTIONS_H\n\n")
        f.write('#include <cyaml/cyaml.h>\n\n')

        # Generate structs for variable fields
        f.write("/* Structure for variable fields */\n")
        f.write("typedef struct {\n")
        f.write("    char *name;\n")
        f.write("    int width;\n")
        f.write("} variable_field_t;\n\n")

        # Generate a top-level instruction struct
        f.write("/* Top-level structure for an instruction */\n")
        f.write("typedef struct {\n")
        f.write("    char *name;\n")
        f.write("    char *description;\n")
        f.write("    char *isa;\n")
        f.write("    char *format;\n")
        f.write("    char *opcode;\n")
        f.write("    variable_field_t *variable_fields;\n")
        f.write("    unsigned num_variable_fields;\n")
        f.write("} instruction_t;\n\n")

        # Generate data definitions
        f.write("/* Data definitions from YAML */\n")
        instruction_list = []
        for name, details in yaml_data.items():
            instruction_list.append(name)
            
            # Variable fields
            var_fields = details.get('variable_fields', [])
            f.write(f"static variable_field_t fields_{name}[] = {{\n")
            for field in var_fields:
                f.write(f'    {{"{field["name"]}", {field["width"]}}},\n')
            f.write("};\n\n")

            # Instruction instance
            f.write(f"static instruction_t inst_{name} = {{\n")
            f.write(f'    .name = "{name}",\n')
            f.write(f'    .description = "{details["description"]}",\n')
            f.write(f'    .isa = "{details["isa"]}",\n')
            f.write(f'    .format = "{details["format"]}",\n')
            f.write(f'    .opcode = "{details["opcode"]}",\n')
            f.write(f'    .variable_fields = fields_{name},\n')
            f.write(f'    .num_variable_fields = {len(var_fields)}\n')
            f.write("};\n\n")

        # Create a top-level array of all instructions
        f.write("/* Array of all instructions */\n")
        f.write("static instruction_t *all_instructions[] = {\n")
        for name in instruction_list:
            f.write(f"    &inst_{name},\n")
        f.write("};\n\n")

        f.write("#endif /* INSTRUCTIONS_H */\n")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python yaml_to_c.py <input.yml> <output.h>")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]

    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found.")
        sys.exit(1)

    with open(input_file, 'r') as f:
        data = yaml.safe_load(f)

    generate_c_header(data, output_file)
    print(f"Successfully generated C header file: '{output_file}'")
